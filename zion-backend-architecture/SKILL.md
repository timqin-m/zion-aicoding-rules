---
description: Zion.app backend architecture and GraphQL API setup for headless BaaS integration. Use when: (1) Setting up Apollo Client or GraphQL client for Zion backend, (2) Configuring authentication (email/phone/username), (3) Establishing WebSocket connections for subscriptions, (4) Understanding Zion's GraphQL endpoint structure, (5) Working with JWT tokens and permission roles
alwaysApply: true
---
# Zion.app

Zion is a full-stack no-code development platform, but its backend architecture is designed to be used headlessly.  This allows building completely custom frontend applications while leveraging Zion as a pure backend-as-a-service (BaaS).

## Core Architecture

* **Database**: A powerful, enterprise-grade relational database built on PostgreSQL.  This provides the foundation for structured data, relationships, and constraints.
* **Actionflow**: For building custom workflows and automations.
* **Third-party API**: Imported third-party HTTP API definitions, the server acts as a relay. 
* **AI Agent**: AI agent builder / runtime capable of RAG, tool use (depending on model), multi-modal input/output (dpending on model), structured JSON output (depending on model). 
* **GraphQL**: All backend interactions, including data operations and business logic execution, are exposed through a single, unified GraphQL API.  There are no traditional REST endpoints for data CRUD operations.
  - **HTTP URL**:  https://zion-app.functorz.com/zero/{projectExId}/api/graphql-v2
  - **WebSocket URL**: wss://zion-app.functorz.com/zero/{projectExId}/api/graphql-subscription

## Communicating with the backend
When using Typescript, to communicate with a Zion.app project's backend server's GraphQL API, use Apollo GraphQL + subscriptions-transport-ws. 
### Reference Implementation
```typescript
import { ApolloClient, InMemoryCache, HttpLink, split } from '@apollo/client';
import { getMainDefinition } from '@apollo/client/utilities';
import { WebSocketLink } from '@apollo/client/link/ws';
import { SubscriptionClient } from 'subscriptions-transport-ws';

const httpUrl = 'https://zion-app.functorz.com/zero/{projectExId}/api/graphql-v2';
const wssUrl = 'wss://zion-app.functorz.com/zero/{projectExId}/api/graphql-subscription';

export const createApolloClient = (token?: string) => {
  const wsClient = new SubscriptionClient(wssUrl, {
    reconnect: true,
    connectionParams: token ? {
      authToken: token // Anonymous users have no token, connectionParams must be empty. 
    } : {},
  });

  const wsLink = new WebSocketLink(wsClient);

  const splitLink = split(
    ({ query }) => {
      const definition = getMainDefinition(query);
      return (
        definition.kind === 'OperationDefinition' &&
        definition.operation === 'subscription'
      );
    },
    wsLink,
    new HttpLink({
      uri: httpUrl,
      headers: token ? { Authorization: `Bearer ${token}` } : {},
    })
  );

  return new ApolloClient({
    link: splitLink,
    cache: new InMemoryCache(),
  });
};
```
For other languages, infer implemenation from the above example. 

## Authentication

All requests to the GraphQL endpoint are either authenticated, or they will be assigned an anonymous user role. 
When user changes authentication status (logging in/out), WebSocket connection should be re-established. 

In order to obtain JWT, user must either register or login. Depending on the login settings of the project, it can have different authentication methods. 
- Email with verification
    1. When registering, you must first send a verification code. Valid values for verificationEnumType are: LOGIN, SIGN_UP, BIND, UNBIND, DEREGISTER,RESET_PASSWORD. In this case, choose SIGN_UP.
        ```graphql 
        mutation SendVerificationCodeToEmail(
            $email: String!
            $verificationEnumType: verificationEnumType!
        ) {
            sendVerificationCodeToEmail(
            email: $email
            verificationEnumType: $verificationEnumType
            )
        }
        ``` 
    2. When registering, use set register to true, and fill in the verificationCode. When logging in subsequently, set register to false and omit verificationCode. 
    ```graphql
    mutation AuthenticateWithEmail(
        $email: String!
        $password: String!
        $verificationCode: String
        $register: Boolean!
    ) {
        authenticateWithEmail(
        email: $email
        password: $password
        verificationCode: $verificationCode
        register: $register
        ) {
            account {
                id
                permissionRoles
            }
            jwt {
                token
            }
        }
    }
    ```
- Username and password
```graphql
  mutation AuthenticateWithUsername(
    $username: String!
    $password: String!
    $register: Boolean!
  ) {
    authenticateWithUsername(
      username: $username
      password: $password
      register: $register
    ) {
      account {
        id
        permissionRoles
      }
      jwt {
        token
      }
    }
  }
```  
N.B. both authentication mutations returns FZ_Account type, which is not the same as the account. FZ_Account ONLY has the following fields: email - String, id - Long, permissionRoles - [String], phoneNumber - String, profileImageUrl - String, roles - [FZ_role], username - String. Other fields in account are NOT found in FZ_Account. 

## Interacting with the GraphQL API
The GraphQL API is automatically generated by Zion.app depending on the structure of the backend. Long and bigint are sometimes used to represent corresponding fields of similar types, such as FZ_Account's id (long) and account's id (bigint), but the exact type must be chosen depending the type involved in the query. Inputs of Json type must be passed in as whole in variables. e.g. 
```graphql
mutation CreateOrder($args: Json!) {
  fz_invoke_action_flow(
    actionFlowId: "7e93e65e-7730-470c-b2fd-9ff608cb68e8"
    versionId: 5
    args: $args
  )
}
```
```json
{
  "variables": {
    "course_id": 2
  }
}
```
AVOID assembling args inside the query. 

### Backend Structure Discovery
Use the momen MCP server for this. 

### Database
Always ensure momen-database-gql-api-rules is read before writing code to interact with the databse. 

### Third-party API
Always ensure momen-tpa-gql-api-rules is read before writing code to interact with any Third-party APIs.

### Actionflow
Always ensure momen-actionflow-gql-api-rules is read before writing code to interact with any Actionflows.

### AI Agent
Always ensure momen-ai-agent-gql-api-rules is read before writing code to interact with any AI Agents.

### Subscriptions

For real-time functionality, the GraphQL API supports subscriptions. A client can subscribe to data, and the server will automatically push updates when that data changes in the database, enabling features like live chat or notifications.  
Once Websocket is established, the initial connection_init message will be acknowledged by the server with 
```json
{
  "id": null,
  "type": "connection_ack",
  "payload": null
}
```
You can then start sending subscriptions.
```json
{
    "id": "some id, unique per websocket", 
    "type": "start",
    "payload": {
    "operationName": "OperationName",
    "query": "subscription OperationName($arg0: String!) {  account (    where: {      username: {        _eq: $arg0      }    }  ) {    __typename    id    username  }}",
    "variables": { "arg0": "someName" }
    }
}
```
You will get answers similar to this:
```json
{
  "id": "2",
  "type": "data",
  "payload": {
    "data": {
      "account": [
        {
          "__typename": "account",
          "id": 1000000000000004,
          "username": "jiangyaokai"
        }
      ]
    }
  }
}
```

## File / Binary Asset Handling
Media and other files are not stored in the PostgreSQL database but in a dedicated Object Storage system.  
When using them as input / parameter in other parts of the system, always use the corresponding id instead. Urls can not be used as inputs in place of a file / image / video.  
When using a media file on the frontend, make sure to fetch its `url` subfield. 
Refer to momen-binary-asset-upload-rules

## Permission
All GraphQL fields have permission control based on the current logged in user's role(s). If an attempted access violates permission policies, an error will be given within the GraphQL response. The key to look for here is the 403 error code.   
e.g.
```json
{
  "errors": [
    {
      "errorCode": 403,
      "extensions": {
        "classification": "ACTION_FLOW"
      },
      "locations": [
        {
          "column": 2,
          "line": 2
        }
      ],
      "message": "Anonymous user has no permission on invocation of action flow: 63734821-319d-4f00-a5cf-69f134b42b9c",
      "operation": "fz_invoke_action_flow",
      "path": [
        "fz_invoke_action_flow"
      ]
    }
  ]
}
```